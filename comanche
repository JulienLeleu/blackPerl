#!/usr/bin/perl

use Socket;
use File::MimeInfo;
use POSIX qw(mkfifo);
use POSIX ":sys_wait_h";

# On conserve la commande (start, stop, status)
$cmd = $ARGV[0];

# Liste des arguments valides
@args = ('start', 'stop', 'status');

# On sort si la commande n'est pas correcte
die "Usage: $0 <start|stop|status>\n" unless(grep { $cmd eq $_ } @args);

# Nom du serveur
$SERVER_NAME = "blackPerl";

# Version du serveur
$SERVER_VERSION = "blackPerl v1.0";

# On stocke le processus du serveur (le père) dans un fichier caché à la racine du serveur
$SERVER_FILE = '.serv_pid';
$server_pid;

# Ports minimal et maximal
$PORT_MIN = 1;
$PORT_MAX = 65535;

# Map qui contient les codes HTTP avec leur erreur HTTP
$HTTP{200} = "OK";
$HTTP{400} = "Bad Request";
$HTTP{403} = "Forbidden";
$HTTP{404} = "Not Found";
$HTTP{405} = "Method Not Allowed";
$HTTP{415} = "Unsupported Media Type";
$HTTP{503} = "Service Unavailable";
$HTTP{505} = "HTTP Version Not Supported";

# Les différents media type supportés
@MEDIA_TYPE = ('text/plain', 'text/html', 'text/css', 'image/png');

# Map qui contient la configuration du serveur
%conf;

# Liste des clients connectés sur le serveur
@clients = ();

# Les compteurs de requêtes pour le status
$req_received = 0;
$req_processed = 0;

# On définit le chemin de la fifo (pipe) pour la lecture/ecriture des status
$fifo = '/tmp/blackPerl.fifo';

# On retrouve le pid du serveur dans le fichier $SERVER_FILE
sub get_server_pid
{
	open(READER, "<$SERVER_FILE") or die "Le serveur n'est pas allumé.\n";
	$server_pid = <READER>;
	close(READER) or die "close: $!";
	return $server_pid;
}

# Charge la configuration du serveur
sub load_config
{
	open CONFIG, "comanche.conf" or die "open: $!\n";
	$error = "[Erreur de configuration]";
	while(<CONFIG>)
	{
		# La ligne est du type "set <key> <value>"
		if (/^set\s+(.+)\s+(.+)$/)
		{
			($key, $val) = ($1, $2);
			# La clé peut valoir (port, error, index, logfile, clients)
			if ($key eq "port")
			{
				die "$error Port $val invalide (le port doit etre compris entre $PORT_MIN et $PORT_MAX)\n" unless($val =~ /[\d+]/ && $val >=$PORT_MIN && val <= $PORT_MAX);
			}
			elsif ($key eq "error")
			{
				die	"$error Fichier d'erreur introuvable\n" unless(-f $val);
			}
			elsif ($key eq "clients")
			{
				die("$error Nombre de clients invalide (requiert un entier) \n") unless($val =~ /\d+/);
			}
			# A ne pas vérifier car vérification dynamique pendant l'utilisation du serveur
			# elsif ($key eq "index") {}
			# elsif ($key eq "logfile") {}
			$conf{'sets'}{$key} = $val;
		}
		# La ligne est du type "route <regex> to <regex>"
		elsif (/^route\s+(.+?)\s+to+\s+(.+)/)
		{
			($key, $val) = ($1, $2);
			$conf{'routes'}{$key} = $val;
			push(@{$conf{'rules'}}, $key);
		}
		# La ligne est du type "exec <regex> to <regex>"
		elsif (/^exec\s+(.+?)\s+from\s+(.+)/)
		{
			($key, $val) = ($1, $2);
			$conf{'exec'}{$key} = $val;
			# On envoit la clé dans une map générale de clé "rules"
			# Ce système permet de conserver l'ordre d'exécution des règles
			# telles qu'elles ont été écrites dans le fichier
			push(@{$conf{'rules'}}, $key);
		}
	}
	close(CONFIG) or die "close: $!\n";
}

# Récupère la route configurée et associée à la requête HTTP
# sous la forme d'une liste : (type_de_projection, clé_projection, valeur_projection)
sub get_info_route
{
	$req = $_[0];
	# Parcours de toutes les règles de réécriture (routes & exec) DANS L'ORDRE
	for $route (@{$conf{'rules'}})
	{
		if ($req =~ /$route/)
		{
			if (exists $conf{'routes'}{$route})
			{
				return ('route', $route, $conf{'routes'}{$route});
			}
			elsif (exists $conf{"exec"}{$route})
			{
				return ('exec', $route, $conf{'exec'}{$route});
			}
		}
	}
	# On retourne undef si aucune projection ne correspond
	return undef;
}

# Récupère le chemin réel d'un fichier demandé par la requête HTTP 
sub get_real_path
{
	# Retourne un tableau avec les informations sur la position du fichier dans le système de fichiers
	my @route = get_info_route($_[0]);	
	# On affecte a motif une expression qui peut etre utilisée a la place d'une expression perl
	my $motif = qr/$route[1]/;
	# On redefinie la variable par defaut
	$_ = $_[0];
	# On vérifie si la chaîne comporte le motif
	my @matches = m/$motif/;
	# On indique la route à prendre
	my $r = $route[2];
	for (@matches)
	{
		$m = $matches[$i++];
		$r =~ s{\\$i}{$m};
	}
	m/$r/;

	# Si la route à prendre est un dossier, on verifie l'existence d'un fichier par défaut à l'intérieur
	if (-d $r)
	{
		$default_file = $r . $conf{'sets'}{'index'};
		if (-f $default_file)
		{
			$r = $default_file;
		}
	}
	
	# On finit par retourner le type de route et l'uri du fichier
	return ($route[0], $r);
}

# Ferme le handle CLIENT et ferme le processus
sub close_and_exit
{
	close CLIENT;
	exit(0);
}

# Envoie l'en-tête de réponse au client
sub send_header
{
	($code, $response, $mime, $length) = @_;
	print CLIENT "HTTP/1.1 $code $response\r\n";
	print CLIENT "Connection: close\r\n" unless ($code == 200);
	print CLIENT "Content-Type: $mime\r\n", "Content-Length: $length\r\n", "\r\n";
}

# Envoie un fichier au client
sub print_file
{
	$buffer = "";
	$length = 1024;
	$file = $_[0];
	
	open FILE, $file;
	while (read(FILE, $buffer, $length))
	{
		print CLIENT $buffer;
	}
	close FILE;
}

# Envoie un fichier au client via une projection de type 'route'
sub exec_route
{
	info("get-s", get_ip_client(), @_);
	print_file($file);
}

# Envoie le résultat d'un CGI au client
sub exec_cgi
{
	info("get-d", get_ip_client(), @_);
	print_file("-| perl $file");
}

# Envoie un fichier au client (code HTTP 200)
sub send_file
{
	$buffer = "";
	$length = 100;
	$code = 200;
	$response = $HTTP{$code};
	($route, $file, $req) = @_;
	
	# Si le fichier est un dossier, on crée une représentation HTML de celui-ci
	if (-d $file)
	{
		$html = list_folder($file, $req);
		send_header($code, $response, 'text/html', length($html));
		print CLIENT $html;
		close_and_exit();
	}
	else
	{
		$mime = mimetype($file);
		# Si le type mime est supporté par le serveur, on continue
		if (grep { $mime eq $_ } @MEDIA_TYPE)
		{
			send_header($code, $response, $mime, (-s $file));
			# Si route vaut "route", on ouvre le fichier
			if ($route eq "route")
			{
				exec_route($req, $file, $code);
			}
			# S'il vaut "exec", on exécute le fichier et on lis sa sortie
			elsif ($route eq "exec")
			{
				exec_cgi($req, $file, $code);
			}
			close_and_exit();
		}
		# On renvoie une erreur dans le cas contraire
		else
		{
			send_error(415);
		}
	}
}

# Envoie une erreur HTTP au client via le code HTTP en paramètre
sub send_error
{
	$default_page = $conf{'sets'}{'error'};
	($code, $exit) = @_;
	$error = $HTTP{$code};
	
	# Si le code d'erreur est 404 et qu'on a une page déjà établie, on l'affiche
	# Dans le cas contraire, on crée une page d'erreur dynamiquement
	if ($code == 404 and -e $default_page)
	{
		send_header($code, $error, mimetype($default_page), (-s $default_page));
		print_file($default_page);
	}
	else
	{
		$html = "<html>\r\n<head>\r\n<title>$error</title>\r\n</head>\r\n<body>\r\n<h1>$error</h1>\r\n<hr>\r\n<p>$SERVER_VERSION</p>\r\n</body>\r\n</html>\r\n\r\n";
		send_header($code, $error, 'text/html', length($html));
		print CLIENT $html;
	}
	# Si le serveur doit gérer lui même le cas d'erreur (ex: HTTP 503), on en ferme pas son processus
	close_and_exit() if $exit;
	return 1;
}

# Génère une page pour la navigation des dossiers si le dossier ne contient pas de fichier par défaut (type index.html)
sub list_folder
{
	($dir, $req) = @_;
	@folder = split("/", $dir);
	$parent = join('/', ($folder[0]..$folder[-1]));
	my $reponse = "<html><head><title>$SERVER_NAME - $dir</title></head>". "<body><h1>Index of : $req</h1><hr/><ul>";

	opendir(REP,"$dir") or die "opendir: $!";
	my @liste = sort readdir(REP);
	closedir REP;

	#pour tout les elements dans la liste
	foreach (@liste)
	{
		if (-d $i) {
			$reponse .= " <li><a href=$req/$_\/>$_</a></li>\n";
		}
		else {
			$reponse .= " <li><a href=$req/$_>$_</a></li>\n";
		}
	}

	$reponse .= "</ul><hr><p>$SERVER_VERSION</p></body></html>";
	return $reponse;
}

sub get_ip_client
{
	$peer = getpeername(CLIENT);
	($port, $iaddr) = sockaddr_in($peer);
	return inet_ntoa($iaddr);
}

# Récupère la date locale formatée du serveur
sub get_date
{
	my ($s, $mn, $h, $j, $m, $a) = localtime(time);

	# Formatage de la date (ajoute des 0 si inferieur a 10)
	$j	= sprintf("%.2d", $j);
	$m	= sprintf("%.2d", $m + 1);
	$s  = sprintf("%.2d", $s);
	$mn = sprintf("%.2d", $mn);
	$h  = sprintf("%.2d", $h);
	$a	= $a + 1900;
	
	return "$j/$m/$a:$h:$mn:$s";
}


# Permet d'ajouter les événements au fichier de log définit dans la configuration
sub info
{
	# On ouvre le fichier de log pour écrire dedans, s'il n'existe pas, il est créé
	open LOG, ">>" . $conf{'sets'}{'logfile'};
	$, = ";";
	print LOG get_date(), @_, "\n";
	$, = "";
	close(LOG);
}

# Formate une ligne de sorte que les \r et \n soient supprimés
sub remove_EOL
{
	return s/(\r|\n)+//g;
}

# Gère la connexion d'un client au serveur
# Pour le fils : on retourne le handle CLIENT
# Dans les autres cas : on retourne la vision du handle comme étant "undef" (donc false)
sub accept_client
{
	if (!accept(CLIENT, SERVER))
	{
		return undef;
	}
	
	# On indique que l'on a reçu une requête
	$req_received++;
	
	# Création d'un client (processus fils)
	$pid = fork();
	if ($pid == -1)
	{
		close CLIENT;
		return undef;
	}
	if ($pid > 0)
	{
		if ($#client < $conf{'sets'}{'clients'})
		{
			# Le processus père n'a pas besoin du client
			close CLIENT;
			# On insére le pid du fils créé dans la liste des clients
			push(@client, $pid);
			# On indique que la requête a été traitée
			$req_processed++;
		}
		# On renvoie l'erreur 503 si la requête ne peut être traitée par le serveur à cause d'un surplus de client
		else
		{
			send_error(503);
		}
		return undef;
	}
	print 'Connexion d\'un client. Numéro de processus: ', $$, "\n";
	return CLIENT;
}

# Crée un serveur web
sub create_server
{	
	# On charge la configuration
	load_config();
	
	# On inscrit le pid du serveur dans un fichier
	$server_pid = $$;
	autoflush WRITER 1;
	open(WRITER, ">$SERVER_FILE");
	print WRITER $server_pid;
	close(WRITER);
	
	$port = $conf{'sets'}{'port'};
	$caddr = sockaddr_in ($port, INADDR_ANY);
	$proto = getprotobyname("tcp");
	
	socket (SERVER, PF_INET, SOCK_STREAM, $proto) or die ("socket: $!");
	setsockopt (SERVER, SOL_SOCKET, SO_REUSEADDR, 1) or die ("setsockopt: $!");
	bind (SERVER, $caddr) or die ("bind: $!");
	listen (SERVER, SOMAXCONN) or die ("listen: $!");

	# On crée la fifo
	mkfifo($fifo, 0666);

	# On définit certains signaux
	$SIG{'CHLD'} = 'wait_children';	# Lorsqu'un fils meurt
	$SIG{'USR1'} = 'status';		# Lorsque l'utilisateur exécute ./comanche status
	$SIG{'PIPE'} = 'IGNORE';		# Lorsqu'un PIPE est cassé
	$SIG{'INT'} = 'stop';			# Lorsque l'on fait ^C

	info("start", "local", $port , "", "");
	print "$SERVER_VERSION (pid = $server_pid) démarré.\n";
}

# Parse la requête HTTP et retourne une liste sous la forme ($method, $req, $http)
sub parse_http_request
{
	($method, $req, $http) = split(" ", scalar <CLIENT>);
	$http =~ remove_EOL($http);
	
	return ($method, $req, $http);
}

# Démarre le serveur
sub run
{
	create_server();
	for (;;)
	{
		if (accept_client())
		{
			($method, $req, $http) = parse_http_request();
			
			while (<CLIENT>)
			{
				remove_EOL;
				if (not $_)
				{
					# On renvoie l'erreur 400 si la requête est mal formulée
					send_error(400) unless ($method eq 'GET' && $http eq 'HTTP/1.1');
					# On récupère le chemin réel de la ressource demandée par le client
					($route, $file) = get_real_path($req);
					# On renvoie l'erreur 404 si la ressource n'existe pas à l'emplacement prévue
					send_error(404) unless (-e $file);
					# Si aucune erreur, on envoie le fichier au client
					send_file($route, $file, $req);
				}
			}
		}
	}
}

sub wait_children {
	my $kid;
	while (($kid = waitpid(-1, WNOHANG)) > 0)
	{
		print "Adieu $kid\n";
		# On supprime le fils de la liste des clients
		@client = grep { $_ != $kid } @client;
	}
}

# Arrêt du serveur lui-même (fonction appelée soit par ./comanche stop soit par ^C)
sub stop
{
	print "[$$] Arrêt de $SERVER_VERSION en cours ...\n";
	info("stop", "local", $port , "", "");
	# On attend la fermeture de tous les fils
	wait_children();
	# On clos la socket SERVER
	close SERVER;
	# On supprime le numéro de processus du père contenu dans un fichier
	unlink($SERVER_FILE);
	# On termine le programme
	kill('TERM', $server_pid);
}

# Affiche le status du serveur
sub status
{
	# Ouvrir le mkfifo en écriture et envoyer le status dedans
	open(WRITER, ">$fifo") or die "open : $!";
	autoflush WRITER 1;
	
	$, = " ";
	print WRITER "Numéro de processus père : $$\n",
			"Requêtes :\n",
			"\t- reçues : $req_received \n",
			"\t- traitées : $req_processed \n",
			"Clients: " . ($#client + 1) . "\n\t",
			@client, "\n";
	$, = "";
	close(WRITER) or die "close : $!";
}

if ($cmd eq 'stop')
{
	# On demande au serveur de s'arrêter (il passe dans la fonction stop)
	kill('INT', get_server_pid());
}
elsif ($cmd eq 'status')
{
	# On envoie un signal au serveur pour récupérer le status qui sera stocké dans la fifo
	kill('USR1', get_server_pid());
	# On lis les informations dans la fifo
	open(READER, "<$fifo") or die "open : $!";
	# On affiche la seule ligne stockée dans la fifo
	print <READER>;
	# On ferme la lecture de la fifo
	close(READER) or die "close : $!";
}
# Ici la commande vaut forcément 'start'
elsif (-e $SERVER_FILE) 
{
	print "$SERVER_VERSION est déjà en cours d'execution\n"; 
}
else
{
	run();
}
