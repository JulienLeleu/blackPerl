#!/usr/bin/perl

use Socket;
use File::MimeInfo;
use POSIX qw(mkfifo);
use POSIX ":sys_wait_h";

# On conserve la commande (start, stop, status)
$cmd = $ARGV[0];

# On sort si la commande n'est pas correcte
die "Usage: $0 <start|stop|status>\n" if (!($cmd eq "start" or $cmd eq "stop" or $cmd eq "status"));

# Nom du serveur
$SERVER_NAME = "blackPerl";

# Version du serveur
$SERVER_VERSION = "blackPerl v1.0";

# Ports minimal et maximal
$PORT_MIN = 1;
$PORT_MAX = 65535;

# Map qui contient les codes HTTP avec leur erreur HTTP
$HTTP{200} = "OK";
$HTTP{400} = "Bad Request";
$HTTP{403} = "Forbidden";
$HTTP{404} = "Not Found";
$HTTP{405} = "Method Not Allowed";
$HTTP{415} = "Unsupported Media Type";
$HTTP{503} = "Service Unavailable";
$HTTP{505} = "HTTP Version Not Supported";

# Map qui contient la configuration du serveur
%conf;

# Liste des clients connectés sur le serveur
@clients = ();

# Les compteurs de requêtes pour le status
$req_received = 0;
$req_processed = 0;

# On définit le chemin de la fifo (pipe) pour la lecture/ecriture des status
$fifo = '/tmp/blackPerl.fifo';

# On stocke le processus du serveur (le père) dans un fichier caché à la racine du serveur
$serverFile = '.serv_pid';
$serverPid;

# On retrouve le pid du serveur dans le fichier $serverFile
sub getServerPid
{
	local $pid;
	open(READER, "<$serverFile") or die "Le serveur n'est pas allumé.\n";
	$pid = <READER>;
	close(READER) or die "close: $!";
	return $pid;
}

# Affiche le status du serveur
sub status
{
	# Ouvrir le mkfifo en écriture et envoyer le status dedans
	# TODO
	open(WRITER, ">$fifo") or die "open : $!";
	autoflush WRITER 1;
	
	$, = " ";
	print WRITER "Numéro de processus père : $$\n" .
			"Requêtes :\n" .
			"\t- reçues : $req_received \n" .
			"\t- traitées : $req_processed \n" .
			"Clients: " . ($#client + 1) . "\n\t", @client, "\n";
	$, = "";
	close(WRITER) or die "close : $!";
}

# Charge la configuration du serveur
sub loadConfig
{
	$error = "[Erreur de configuration]";
	open CONFIG, "comanche.conf" or die "open: $!\n";
	while(<CONFIG>)
	{
		# La ligne est du type "set <key> <value>"
		if (/^set\s+(.+)\s+(.+)$/)
		{
			($key, $val) = ($1, $2);
			# La clé peut valoir (port, error, index, logfile, clients)
			if ($key eq "port")
			{
				die "$error Port $val invalide (le port doit etre compris entre $PORT_MIN et $PORT_MAX)\n" unless($val =~ /[\d+]/ && $val >=$PORT_MIN && val <= $PORT_MAX);
			}
			elsif ($key eq "error")
			{
				die	"$error Fichier d'erreur introuvable\n" unless(-f $val);
			}
			elsif ($key eq "clients")
			{
				die("$error Nombre de clients invalide (requiert un entier) \n") unless($val =~ /\d+/);
			}
			# A ne pas vérifier car vérification dynamique pendant l'utilisation du serveur
			# elsif ($key eq "index") {}
			# elsif ($key eq "logfile") {}
			$conf{"sets"}{$key} = $val;
		}
		# La ligne est du type "route <regex> to <regex>"
		elsif (/^route\s+(.+?)\s+to+\s+(.+)/)
		{
			($key, $val) = ($1, $2);
			$conf{"routes"}{$key} = $val;
			push(@{$conf{"rules"}}, $key);
		}
		# La ligne est du type "exec <regex> to <regex>"
		elsif (/^exec\s+(.+?)\s+from\s+(.+)/)
		{
			($key, $val) = ($1, $2);
			$conf{"exec"}{$key} = $val;
			# On envoit la clé dans une map générale de clé "rules"
			# Ce système permet de conserver l'ordre d'exécution des règles
			# telles qu'elles ont été écrites dans le fichier
			push(@{$conf{"rules"}}, $key);
		}
	}
	close(CONFIG) or die "close: $!\n";
}

# Récupère la date locale formatée du serveur
sub getDate
{
	my ($s, $mn, $h, $j, $m, $a) = localtime(time);

	# Formatage de la date (ajoute des 0 si inferieur a 10)
	$j	= sprintf("%.2d", $j);
	$m	= sprintf("%.2d", $m + 1);
	$s  = sprintf("%.2d", $s);
	$mn = sprintf("%.2d", $mn);
	$h  = sprintf("%.2d", $h);
	$a	= $a + 1900;
	
	return "$j/$m/$a:$h:$mn:$s";
}

# Permet d'ajouter les événements au fichier de log définit dans la configuration
sub info
{
	# On ouvre le fichier de log pour écrire dedans, s'il n'existe pas, il est créé
	open LOG, ">>" . $conf{"sets"}{"logfile"};
	$, = ";";
	print LOG getDate(), @_, "\n";
	$, = "";
	close(LOG);
}

# Récupère la route configurée et associée à la requête HTTP
sub getRoute
{
	$req = $_[0];
	# Parcours de toutes les règles de réécriture (routes & exec) DANS L'ORDRE
	for $route (@{$conf{"rules"}})
	{
		if ($req =~ /$route/)
		{
			if (exists $conf{"routes"}{$route})
			{
				return ("route", $route, $conf{"routes"}{$route});
			}
			elsif (exists $conf{"exec"}{$route})
			{
				return ("exec", $route, $conf{"exec"}{$route});
			}
		}
	}
	# Si on ne trouve aucun résultat, on renvoie une erreur 404
	sendError(404);
	close CLIENT;
	exit 0;
}

# Récupère le chemin réel d'un fichier demandé par la requête HTTP 
sub getRealPath
{
	# Retourne un tableau avec les informations sur la position du fichier dans le système de fichiers
	my @route = getRoute($_[0]);
	# On affecte a param1 une expression qui peut etre utilisée a la place d'une expression perl
	my $motif = qr/$route[1]/;
	# On redefinie la variable par defaut
	$_ = $_[0];
	# On vérifie si la chaîne comporte le motif
	my @matches = m/$motif/;
	# On indique la route à prendre
	my $r = $route[2];
	for (@matches)
	{
		$m = $matches[$i++];
		$r =~ s{\\$i}{$m};
	}
	m/$r/;

	# Si la route à prendre est un dossier, on verifie l'existence d'un fichier par défaut à l'intérieur
	if (-d $r)
	{
		$default_file = $r . $conf{"sets"}{"index"};
		if (-f $default_file)
		{
			$r = $default_file;
		}
	}
	
	# On finit par retourner le type de route et l'uri du fichier
	return ($route[0], $r);
}

# Envoie l'en-tête de réponse au client
sub sendHeader
{
	($code, $response, $mime, $length) = @_;
	print CLIENT "HTTP/1.1 $code $response\r\n" .
				"Content-Type: " . $mime . "\r\n" .
				"Content-Length: " . $length . "\r\n\r\n";
}

# Envoie un fichier au client
sub printFile
{
	$buffer = "";
	$length = 1024;
	$file = $_[0];
	
	open FILE, $file;
	while (read(FILE, $buffer, $length))
	{
		print CLIENT $buffer;
	}
	close FILE;
}

# Envoie un fichier au client (code HTTP 200)
sub sendFile
{
	$buffer = "";
	$length = 100;
	$code = 200;
	$response = $HTTP{$code};
	($route, $file, $req) = @_;
	
	sendHeader($code, $response, mimetype($file), (-s $file));
	
	# Si route vaut "route", on ouvre le fichier
	if ($route eq "route")
	{
		info("get-s", getIPClient(), $req, $file, $code);
		printFile($file);
	}
	# S'il vaut "exec", on exécute le fichier et on lis sa sortie
	elsif ($route eq "exec")
	{
		info("get-d", getIPClient(), $req, $file, $code);
		printFile("-| perl $file");
	}
}

# Envoie une erreur HTTP au client via le code HTTP en paramètre
sub sendError
{
	$page404 = $conf{"sets"}{'default'};
	$code = $_[0];
	$error = $HTTP{$code};
	
	sendHeader($code, $error, 'text/html', length($html));
	
	# Si le code d'erreur est 404 et qu'on a une page déjà établie, on l'affiche
	# Dans le cas contraire, on crée une page d'erreur dynamiquement
	if ($code == 404 and -e $page404)
	{
		printFile($page404);
	}
	else
	{
		$html = "<html>\r\n<head>\r\n<title>$error</title>\r\n</head>\r\n<body>\r\n<h1>$error</h1>\r\n<hr>\r\n<p>$SERVER_VERSION</p>\r\n</body>\r\n</html>\r\n\r\n";
		print CLIENT $html;
	}
}

# Envoie un dossier
sub sendFolder
{
	$code = 200;
	$response = $HTTP{$code};
	$html = listFolder(@_);
	
	sendHeader($code, $response, 'text/html', length($html));
	
	print CLIENT $html;
}

# Génère une page pour la navigation des dossiers si le dossier ne contient pas de fichier par défaut (type index.html)
sub listFolder
{
	($dir, $req) = @_;
	@folder = split("/", $dir);
	$parent = join('/', ($folder[0]..$folder[-1]));
	my $reponse = "<html><head><title>$SERVER_NAME - $dir</title></head>". "<body><h1>Index of : $req</h1><hr/><ul>";

	opendir(REP,"$dir") or die "opendir: $!";
	my @liste = sort readdir(REP);
	# On supprime le dossier courant
	closedir REP;

	#pour tout les elements dans la liste
	foreach (@liste)
	{
		if (-d $i) {
			$reponse .= " <li><a href=$req/$_\/>$_</a></li>\n";
		}
		else {
			$reponse .= " <li><a href=$req/$_>$_</a></li>\n";
		}
	}

	$reponse .= "</ul><hr><p>$SERVER_VERSION</p></body></html>";
	return $reponse;
}

sub getIPClient
{
	$peer = getpeername(CLIENT);
	($port, $iaddr) = sockaddr_in($peer);
	return inet_ntoa($iaddr);
}

# Formate une ligne de sorte que les \r et \n soient supprimés
sub removeEOL
{
	return s/(\r|\n)+//g;
}

# Démarre le serveur
sub run
{
	print "Démarrage de $SERVER_VERSION (pid = $serverPid)\n";
	
	# On charge la configuration
	loadConfig();
	$port = $conf{"sets"}{"port"};
	$caddr = sockaddr_in ($port, INADDR_ANY);
	$proto = getprotobyname("tcp");
	
	socket (SERVER, PF_INET, SOCK_STREAM, $proto) or die ("socket: $!");
	setsockopt (SERVER, SOL_SOCKET, SO_REUSEADDR, 1) or die ("setsockopt: $!");
	bind (SERVER, $caddr) or die ("bind: $!");
	listen (SERVER, SOMAXCONN) or die ("listen: $!");

	# On crée la fifo
	mkfifo($fifo, 0666);

	# On définit certains signaux
	$SIG{'CHLD'} = 'waitChildren';	# Lorsqu'un fils meurt
	$SIG{'USR1'} = 'status';		# Lorsque l'utilisateur exécute ./comanche status
	$SIG{'PIPE'} = 'IGNORE';		# Lorsqu'un PIPE est cassé
	$SIG{'INT'} = 'stop';			# Lorsque l'on fait ^C

	info("start", "local", $port , "", "");
	for (;;)
	{
		if (accept (CLIENT, SERVER))
		{
			# On indique que l'on a reçu une requête
			$req_received++;
			
			# Le serveur ne peut pas accueillir un client supplémentaire
			# On avertit le client qui tente de se connecter
			if ($#client >= $conf{"sets"}{"clients"})
			{
				sendError(503);
			}
			else
			{
				$pid = fork();
				if ($pid == 0)
				{
					($get, $req, $http) = split(" ", scalar <CLIENT>);
			
					$http =~ removeEOL($http);
					while (<CLIENT>)
					{
						removeEOL;
						if (not $_)
						{
							if ($get eq "GET" && $http eq "HTTP/1.1")
							{
								($route, $file) = getRealPath($req);
								if (-e $file)
								{
									if (-d $file)
									{
										sendFolder($file, $req);
									}
									else
									{
										sendFile($route, $file, $req);
									}
								}
								else {
									sendError(404);
								}
							}
							else
							{
								sendError(400);
							}
							close CLIENT;
							exit(0);
						}
					}
				}
				else {
					# On insére le pid du fils créé dans la liste des clients
					push(@client, $pid);
					# On indique que la requête a été traitée
					$req_processed++;
				}
			}
			# Le père n'a pas besoin du CLIENT, on le ferme
			close CLIENT;
		}
	}
}

sub waitChildren {
	do
	{
		$kid = waitpid(-1, WNOHANG);
		# On supprime le fils de la liste des clients
		@client = grep { $_ != $pid } @client;
	} while ($kid > 0);
}

# Arrêt du serveur lui-même (fonction appelée soit par ./comanche stop soit par ^C)
sub stop 
{
	print "[$$] Arrêt de $SERVER_VERSION en cours ...\n";
	info("stop", "local", $port , "", "");
	# On attend la fermeture de tous les fils
	waitChildren();
	# On clos la socket SERVER
	close SERVER;
	# On supprime le numéro de processus du père contenu dans un fichier
	unlink($serverFile);
	# On termine le programme
	kill('TERM', $serverPid);
}

if ($cmd eq "start")
{
	if (-e $serverFile) 
	{
		print "$SERVER_VERSION est déjà en cours d'execution\n"; 
	}
	else
	{
		$serverPid = $$;
		autoflush WRITER 1;
		open(WRITER, ">$serverFile");
		print WRITER $serverPid;
		close(WRITER);
		run();
	}
}
elsif ($cmd eq "stop")
{
	# On demande au serveur de s'arrêter (il passe dans la fonction stop)
	kill('INT', getServerPid());
}
else {
	# On envoie un signal au serveur pour récupérer le status qui sera stocké dans la fifo
	kill('USR1', getServerPid());
	# On lis les informations dans la fifo
	open(READER, "<$fifo") or die "open : $!";
	# On affiche la seule ligne stockée dans la fifo
	print <READER>;
	# On ferme la lecture de la fifo
	close(READER) or die "close : $!";
}
